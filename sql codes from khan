/*nested subquery*/
select*from TABLE1 where VARIABLE1 in (select VARIABLE1 from TABLE2);
select*from TABLE1 where VARIABLE1 in (select VARIABLE1 from TABLE2 where VARIABLE2 =/like/...operators);
/*example*/
select title from songs where artist in (select name from artists where genre = "Pop"); /*VAR artist in songs shares same value with VAR name in artists*/

SELECT type, SUM(calories) AS total_calories FROM exercise_logs GROUP BY type having total_calories > 100; /*AS serves as assgina name to the sum() so we can use it in following steps. total_calories isn't a new varaible???*/

select author, sum(words) as total_words from books group by author having total_words > 1000000;

/*WHERE filters the data during selection.
HAVING filters the result of the selection.
You can do the same thing like this, but HAVING does the result filtering without the explicit nesting of queries.*/

SELECT type, total_calories FROM (
    SELECT type, 
    SUM(calories) AS total_calories 
    FROM exercise_logs
    GROUP BY type)
WHERE total_calories > 150
    ;
/*another example*/
SELECT type FROM exercise_logs GROUP BY type HAVING COUNT(*) >= 2;

/* Create table step*/
CREATE TABLE exercise_logs
    (id INTEGER PRIMARY KEY AUTOINCREMENT,
    type TEXT,
    minutes INTEGER, 
    calories INTEGER,
    heart_rate INTEGER);

INSERT INTO exercise_logs(type, minutes, calories, heart_rate) VALUES ("biking", 30, 100, 110);
INSERT INTO exercise_logs(type, minutes, calories, heart_rate) VALUES ("biking", 10, 30, 105);
INSERT INTO exercise_logs(type, minutes, calories, heart_rate) VALUES ("dancing", 15, 200, 120);
INSERT INTO exercise_logs(type, minutes, calories, heart_rate) VALUES ("dancing", 15, 165, 120);
INSERT INTO exercise_logs(type, minutes, calories, heart_rate) VALUES ("tree climbing", 30, 70, 90);
INSERT INTO exercise_logs(type, minutes, calories, heart_rate) VALUES ("tree climbing", 25, 72, 80);
INSERT INTO exercise_logs(type, minutes, calories, heart_rate) VALUES ("rowing", 30, 70, 90);
INSERT INTO exercise_logs(type, minutes, calories, heart_rate) VALUES ("hiking", 60, 80, 85);

/* return a count */
SELECT COUNT(*) FROM exercise_logs WHERE
    heart_rate >= ROUND(0.50 * (220-30)) 
    AND  heart_rate <= ROUND(0.90 * (220-30));
    
/* CASE statement*/
SELECT COUNT(*), type, heart_rate,
    CASE 
        WHEN heart_rate > 220-30 THEN "above max"
        WHEN heart_rate > ROUND(0.90 * (220-30)) THEN "above target"
        WHEN heart_rate > ROUND(0.50 * (220-30)) THEN "within target"  /* only one side condition */
        ELSE "below target"
    END as "hr_zone"
FROM exercise_logs
GROUP BY hr_zone;

SELECT COUNT(*),
    CASE 
        WHEN heart_rate > 220-30 THEN "above max"
        WHEN heart_rate > ROUND(0.90 * (220-30)) THEN "above target"
        WHEN heart_rate > ROUND(0.50 * (220-30)) THEN "within target"  /* only one side condition */
        ELSE "below target"
    END as "hr_zone"
FROM exercise_logs
GROUP BY hr_zone;  /* final table only contains 2 columns: count, hr_zone*/

/* multiply and apply function, CASE statement */

CREATE TABLE student_grades (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT,
    number_grade INTEGER,
    fraction_completed REAL);
    
INSERT INTO student_grades (name, number_grade, fraction_completed)
    VALUES ("Winston", 90, 0.805);
INSERT INTO student_grades (name, number_grade, fraction_completed)
    VALUES ("Winnefer", 95, 0.901);
INSERT INTO student_grades (name, number_grade, fraction_completed)
    VALUES ("Winsteen", 85, 0.906);
INSERT INTO student_grades (name, number_grade, fraction_completed)
    VALUES ("Wincifer", 66, 0.7054);
INSERT INTO student_grades (name, number_grade, fraction_completed)
    VALUES ("Winster", 76, 0.5013);
INSERT INTO student_grades (name, number_grade, fraction_completed)
    VALUES ("Winstonia", 82, 0.9045);

select name, number_grade, round(100*fraction_completed) as percent_completed from student_grades;

select count(*),
case 
when number_grade > 90 then "A"
when number_grade > 80 then "B"
when number_grade > 70 then "C"
else "F"
end as "letter_grade"
from student_grades
group by letter_grade;
